---
## Front matter
title: "Шаблон отчёта по лабораторной работе"
subtitle: " Лабораторная работа №8.Программирование цикла.Обработка аргументов командной строки."
author: "Акрур Имад НКАбд-06-24"

## Generic otions
lang: ru-RU
toc-title: "Содержание"

## Bibliography
bibliography: bib/cite.bib
csl: pandoc/csl/gost-r-7-0-5-2008-numeric.csl

## Pdf output format
toc: true # Table of contents
toc-depth: 2
lof: true # List of figures
lot: true # List of tables
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt
## I18n polyglossia
polyglossia-lang:
  name: russian
  options:
	- spelling=modern
	- babelshorthands=true
polyglossia-otherlangs:
  name: english
## I18n babel
babel-lang: russian
babel-otherlangs: english
## Fonts
mainfont: IBM Plex Serif
romanfont: IBM Plex Serif
sansfont: IBM Plex Sans
monofont: IBM Plex Mono
mathfont: STIX Two Math
mainfontoptions: Ligatures=Common,Ligatures=TeX,Scale=0.94
romanfontoptions: Ligatures=Common,Ligatures=TeX,Scale=0.94
sansfontoptions: Ligatures=Common,Ligatures=TeX,Scale=MatchLowercase,Scale=0.94
monofontoptions: Scale=MatchLowercase,Scale=0.94,FakeStretch=0.9
mathfontoptions:
## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric
## Pandoc-crossref LaTeX customization
figureTitle: "Рис."
tableTitle: "Таблица"
listingTitle: "Листинг"
lofTitle: "Список иллюстраций"
lotTitle: "Список таблиц"
lolTitle: "Листинги"
## Misc options
indent: true
header-includes:
  - \usepackage{indentfirst}
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
---

# Цель работы

Приобретение навыков написания программ с использованием циклов и обработкой
аргументов командной строки.

# Описание результатов выполнения лабораторной работы

## Цель работы:  
Ознакомиться с использованием циклов в языке ассемблера NASM, применяя инструкцию `loop` для реализации повторяющихся операций. 

## описание выполняемого задания : 

### Реализация циклов в NASM : 

1. Создать файл для программы: 

   ```bash
   touch lab8-1.asm 
   ``` 
![Создание файла программы](/home/imadakrour/Pictures/lab08/1.png){#fig:0001 width=70%}

2. Ввести текст программы из листинга 8.1 в файл `lab8-1.asm`. Программа выводит значения регистра `ecx` в цикле, начиная с введённого пользователем числа. 


![Скриншот редактора с введённым текстом программы](/home/imadakrour/Pictures/lab08/2.png){#fig:0002 width=70%}

**Программа (Листинг):** 

```asm
;----------------------------------------------------------------
; Программа вывода значений регистра 'ecx'
;----------------------------------------------------------------
%include 'in_out.asm'

SECTION .data
    msg1 db 'Введите N: ', 0h 

SECTION .bss
    N resb 10

SECTION .text
global _start
_start:
    ;----- Вывод сообщения 'Введите N: '
    mov eax, msg1
    call sprint

    ;----- Ввод 'N'
    mov ecx, N
    mov edx, 10
    call sread

    ;----- Преобразование 'N' из символа в число
    mov eax, N
    call atoi
    mov [N], eax

    ;------ Организация цикла
    mov ecx, [N] ; Счетчик цикла, `ecx=N`
label:
    mov [N], ecx
    mov eax, [N]
    call iprintLF ; Вывод значения `N`
    loop label ; `ecx=ecx-1`, если `ecx` не '0', переход на `label`

    call quit
```


**Комментарии и выводы:** 
Программа успешно реализована и проверена. Основной алгоритм работы цикла `loop` понятен, а также рассмотрена работа с регистрами и базовыми функциями ввода/вывода.


![Скриншот выполнения команд компиляции и запуска программы](/home/imadakrour/Pictures/lab08/3.png){#fig:0003 width=70%}

![Скриншот вывода программы после ввода значения `N`](/home/imadakrour/Pictures/lab08/4.png){#fig:0004 width=70%}

**Описание выполняемого задания:** 
1. Модификация программы для работы с циклом, включающая изменение значения регистра `ecx` в теле цикла с использованием команды `sub`. 
2. Проверка корректности работы программы с изменённым значением `ecx`. Ответ на вопрос: соответствует ли число проходов цикла значению `N`, введённому с клавиатуры? 
3. Внесение изменений в программу для корректного использования регистра `ecx` с помощью стека, добавив команды `push` и `pop`. 


**Модифицированный текст программы с `sub ecx, 1`:** 

![Скриншот редактора с введённым текстом программы](/home/imadakrour/Pictures/lab08/5.png){#fig:0005 width=70%}

```asm
;----------------------------------------------------------------
; Программа вывода значений регистра 'ecx' с изменением ecx
;----------------------------------------------------------------
%include 'in_out.asm'

SECTION .data
    msg1 db 'Введите N: ', 0h 

SECTION .bss
    N resb 10

SECTION .text
global _start
_start:
    ;----- Вывод сообщения 'Введите N: '
    mov eax, msg1
    call sprint

    ;----- Ввод 'N'
    mov ecx, N
    mov edx, 10
    call sread

    ;----- Преобразование 'N' из символа в число
    mov eax, N
    call atoi
    mov [N], eax

    ;------ Организация цикла
    mov ecx, [N] ; Счетчик цикла, `ecx=N`
label:
    sub ecx, 1   ; Уменьшение значения ecx на 1
    mov [N], ecx
    mov eax, [N]
    call iprintLF ; Вывод значения `N`
    loop label    ; Переход на `label`, если ecx > 0

    call quit
```

**Выводы по результатам:** 

![Результат работы программы](/home/imadakrour/Pictures/lab08/6.png){#fig:0006 width=70%}

В результате изменения значения регистра `ecx` внутри цикла количество проходов перестаёт соответствовать значению `N`, введённому с клавиатуры, так как `loop` дополнительно уменьшает `ecx` на каждой итерации.  


**Модифицированный текст программы с использованием `push` и `pop`:** 


![Скриншот редактора с введённым текстом программы](/home/imadakrour/Pictures/lab08/7.png){#fig:0007 width=70%}

```asm
;----------------------------------------------------------------
; Программа вывода значений регистра 'ecx' с использованием стека
;----------------------------------------------------------------
%include 'in_out.asm'

SECTION .data
    msg1 db 'Введите N: ', 0h 

SECTION .bss
    N resb 10

SECTION .text
global _start
_start:
    ;----- Вывод сообщения 'Введите N: '
    mov eax, msg1
    call sprint

    ;----- Ввод 'N'
    mov ecx, N
    mov edx, 10
    call sread

    ;----- Преобразование 'N' из символа в число
    mov eax, N
    call atoi
    mov [N], eax

    ;------ Организация цикла
    mov ecx, [N] ; Счетчик цикла, `ecx=N`
label:
    push ecx      ; Сохранение значения ecx в стеке
    sub ecx, 1    ; Уменьшение значения ecx на 1
    mov [N], ecx
    mov eax, [N]
    call iprintLF ; Вывод значения `N`
    pop ecx       ; Восстановление значения ecx из стека
    loop label    ; Переход на `label`, если ecx > 0

    call quit
```


**Выводы по результатам:** 

![Результат работы программы](/home/imadakrour/Pictures/lab08/8.png){#fig:0008 width=70%}

При использовании стека (`push` и `pop`) для сохранения и восстановления значения регистра `ecx`, количество проходов цикла точно соответствует введённому значению `N`. Это подтверждает важность корректного управления регистрами в ассемблерных программах для предотвращения ошибок выполнения. 


**выводы:**  

- Изучена работа с циклом `loop` и управление регистром `ecx`. 
- Выявлена проблема при изменении значения `ecx` внутри цикла без его восстановления. 
- Решение с использованием стека позволило сохранить корректность выполнения программы, соответствующую введённому значению `N`. 
- Практическая работа помогла лучше понять принципы управления регистрами и циклами в языке NASM. 

 

### Обработка аргументов командной строки

![Создание файла программы](/home/imadakrour/Pictures/lab08/9.png){#fig:0009 width=70%}

![Скриншот редактора с введённым текстом программы](/home/imadakrour/Pictures/lab08/10.png){#fig:0010 width=70%}

**1. Текст программы `lab8-2.asm`** 

```asm
;----------------------------------------------------------------
; Обработка аргументов командной строки
;----------------------------------------------------------------
%include 'in_out.asm'

SECTION .text
global _start
_start:
    pop ecx         ; Извлекаем количество аргументов
    pop edx         ; Извлекаем имя программы
    sub ecx, 1      ; Уменьшаем счетчик аргументов (без имени программы)
next:
    cmp ecx, 0      ; Проверяем, остались ли аргументы
    jz _end         ; Если аргументов нет, завершить цикл
    pop eax         ; Извлекаем следующий аргумент
    call sprintLF   ; Печать аргумента с новой строки
    loop next       ; Переход к следующему аргументу
_end:
    call quit       ; Завершение программы
```

![Вывод программы с аргументами:](/home/imadakrour/Pictures/lab08/11.png){#fig:0011 width=70%}


**Вопрос:** Сколько аргументов было обработано программой? 
**Ответ:** Программа обрабатывает все аргументы, кроме имени программы. Например, для запуска `./lab8-2 аргумент1 аргумент2 'аргумент 3'` программа обработает **три аргумента**. 

### Программа вычисления суммы аргументов командной строки

![Создание файла программы](/home/imadakrour/Pictures/lab08/12.png){#fig:0012 width=70%}

![Скриншот редактора с введённым текстом программы](/home/imadakrour/Pictures/lab08/13.png){#fig:0013 width=70%}

**Текст программы `lab8-3.asm` (вычисление суммы аргументов)** 

```asm
;----------------------------------------------------------------
; Вычисление суммы аргументов командной строки
;----------------------------------------------------------------
%include 'in_out.asm'

SECTION .data
    msg db "Результат: ", 0

SECTION .text
global _start
_start:
    pop ecx         ; Извлекаем количество аргументов
    pop edx         ; Извлекаем имя программы
    sub ecx, 1      ; Уменьшаем счетчик аргументов (без имени программы)
    mov esi, 0      ; Инициализируем сумму
next:
    cmp ecx, 0h     ; Проверяем, остались ли аргументы
    jz _end         ; Если аргументов нет, завершить цикл
    pop eax         ; Извлекаем следующий аргумент
    call atoi       ; Преобразуем аргумент в число
    add esi, eax    ; Добавляем число к сумме
    loop next       ; Переход к следующему аргументу
_end:
    mov eax, msg    ; Вывод сообщения "Результат: "
    call sprint
    mov eax, esi    ; Передача суммы в регистр `eax`
    call iprintLF   ; Печать результата
    call quit       ; Завершение программы
```


![Результат вывода суммы аргументов](/home/imadakrour/Pictures/lab08/14.png){#fig:0014 width=70%}

### Выводы:  
- Программа из `lab8-2.asm` успешно обрабатывает и выводит на экран все переданные аргументы, кроме имени программы. 
- Программа `lab8-3.asm` корректно вычисляет сумму числовых аргументов, переданных в командной строке. 
- Модификация программы позволила реализовать вычисление произведения числовых аргументов. Работоспособность проверена, и результат соответствует ожидаемому.


# Описание результатов выполнения заданийдля самостоятельной работы

## Цель работы:

Разработать программу, которая вычисляет сумму значений функции \( f(x) = 10x - 5 \) для заданного набора аргументов \( x_1, x_2, \dots, x_n \).

1. Программа для нахождения наименьшего числа успешно реализована и корректно определяет минимальное значение из трёх целых чисел.
2. Программа для вычисления функции \( f(x) \) корректно обрабатывает входные данные и вычисляет результат в зависимости от условия \( x = 3 \) или \( x \neq 3 \).

## описание выполняемого задания

![Выбор функции](/home/imadakrour/Pictures/lab08/15.png){#fig:0015 width=70%}

![Создание файла программы](/home/imadakrour/Pictures/lab08/16.png){#fig:00016 width=70%}

![Скриншот редактора с введённым текстом программы](/home/imadakrour/Pictures/lab08/17.png){#fig:0017 width=70%}




1. **Выбор функции \( f(x) \):**  
   На основании таблицы 8.1 была выбрана функция:  
   \( f(x) = 10x - 5 \).  

2. **Описание выполняемого задания:**  
   Программа должна:  
   - Получить аргументы из командной строки.  
   - Применить функцию \( f(x) = 10x - 5 \) ко всем аргументам.  
   - Вычислить сумму значений \( f(x) \).  
   - Вывести результат на экран.  

3. **Текст программы:**  


```asm
%include 'in_out.asm'

SECTION .data
    msg_function db "Функция: f(x) = 10x - 5", 0
    msg_result db "Результат: ", 0

SECTION .text
    global _start

_start:
    ; Извлечение количества аргументов
    pop ecx
    pop edx

    ; Уменьшаем количество аргументов на 1 (без имени программы)
    sub ecx, 1

    ; Вывод функции
    mov eax, msg_function
    call sprintLF

    ; Переменная для хранения результата
    mov esi, 0

next:
    cmp ecx, 0 ; Проверка оставшихся аргументов
    jz end_loop ; Переход к завершению, если аргументов больше нет

    pop eax ; Извлекаем следующий аргумент
    call atoi ; Преобразуем в число

    ; Вычисление f(x) = 10x - 5
    mov ebx, 10
    mul ebx ; Умножаем eax на 10
    sub eax, 5 ; Вычитаем 5
    add esi, eax ; Добавляем к сумме

    loop next ; Переход к следующему аргументу

end_loop:
    ; Вывод сообщения о результате
    mov eax, msg_result
    call sprint

    ; Вывод результата
    mov eax, esi
    call iprintLF

    ; Завершение программы
    call quit
```


**Проверка на нескольких наборах данных:**

**Пример 1:**  
   **Команда:**  
   ```bash
   ./main 1 2 3 4
   ```  
   **Вывод:**  
   ```
   Функция: f(x) = 10x - 5
   Результат: 70
   ```

![Результат выполнения программы](/home/imadakrour/Pictures/lab08/18.png){#fig:0018 width=70%}


**Пример 2:**  
   **Команда:**  
   ```bash
   ./main 5 10 15
   ```  
   **Вывод:**  
   ```
   Функция: f(x) = 10x - 5
   Результат: 370
   ```

![Результат выполнения программы](/home/imadakrour/Pictures/lab08/19.png){#fig:0019 width=70%}

---

## Выводы:
- Программа корректно выполняет обработку аргументов командной строки.
- Выбранная функция \( f(x) = 10x - 5 \) успешно применяется ко всем переданным значениям.
- Результаты вычислений программы подтверждены на нескольких наборах данных.

# Выводы,согласованные с целью работы

Цель работы — изучить реализацию циклов в NASM. Использование loop, sub и стека с push/pop позволило обеспечить корректную работу цикла и избежать ошибок при изменении регистра ecx.
